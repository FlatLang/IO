package flatlang/io

import flatlang/time/Time

class File {
  let visible static File EXECUTED_FILE = getExecutedFile()
  let visible static File EXECUTED_DIRECTORY = getExecutedDirectory()

  visible Bool isDirectory {
    get {
      if (!exists) {
        return false
      }

      external {
        if (#{FileGlobal.fs}.lstatSync(#{location.chars.data}).isDirectory()) {
          return true;
        }
      }

      return false
    }
  }

  visible Bool isSymbolicLink {
    get {
      if (!exists) {
        return false
      }

      external {
        if (#{FileGlobal.fs}.lstatSync(#{location.chars.data}).isSymbolicLink()) {
          return true;
        }
      }

      return false
    }
  }

  visible Bool exists {
    get {
      external {
        if (#{FileGlobal.fs}.existsSync(#{location.chars.data})) {
          return true;
        }
      }

      return false
    }
  }

  visible impure File[] files {
    get {
      if (!isDirectory) {
        throw Exception("Must be a directory to list files")
      }

      var list = new File[]
      native Char[] filename

      external {
        #{FileGlobal.fs}.readdirSync(#{location.chars.data}).forEach((f) => {
          #{filename} = f;
          #{list.add(File("#{location}/#{String(filename)}"))};
        });
      }

      return list
    }
  }

  public construct(File parent, String path) {
    this(parent.normalizedLocation + "/" + path.trimStart('/'))
  }

  public construct(visible String location) {
    normalizedLocation = normalizeLocation(location)
  }

  static getExecutedFile() -> File => null {
    native var Char[] data

    external {
      if (typeof __filename !== 'undefined') {
        #{data} = __filename;
      } else {
        #{data} = "";
      }
    }

    return File(String(data))
  }

  static getExecutedDirectory() -> File => null {
    native var Char[] data

    external {
      if (typeof __dirname !== 'undefined') {
        #{data} = __dirname;
      } else {
        #{data} = "";
      }
    }

    return File(String(data))
  }

  public async getCanonicalPath() -> String {
    var current = this
    let names = Array<String>()

    while (current) {
      let target = current.isSymbolicLink ?
        current.getSymbolicLinkTarget() :
        current.normalizedLocation

      if (!normalizedLocation.startsWith(target)) {
        return normalizeLocation(target + "/" + names.join("/"))
      }

      names.unshift(current.name)
      current = current.getParent()
    }

    return normalizedLocation
  }

  public async getSymbolicLinkTarget() -> String {
    native var Char[] data

    external {
      #{data} = await new Promise((resolve, reject) => {
        #{FileGlobal.fs}.readlink(#{location.chars.data}, (err, target) => {
          if (err) {
            reject(err);
          } else {
            resolve(target);
          }
        });
      });
    }

    return normalizeLocation(String(data))
  }

  public getParent() -> File => null {
    if (normalizedLocation.indexOf("/") == normalizedLocation.lastIndexOf("/")) {
      return null
    }

    native var Char[] data

    external {
      #{data} = #{FileGlobal.path}.resolve(#{location.chars.data}, '..');
    }

    return File(String(data))
  }

  public getChild(String location) => File(this.location + "/" + location)

  public async delete(
    Bool: recursive = false,
    Bool: force = false
  ) => true {
    if (!exists) {
      return false
    }

    native var Char[] errorMessage

    external {
      #{errorMessage} = await new Promise(resolve => {
        #{FileGlobal.fs}.rm(#{location.chars.data}, {
          recursive: #{recursive},
          force: #{force}
        }, (err) => {
          if (err) {
            resolve(err.message);
          } else {
            resolve(null);
          }
        });
      });

      if (#{errorMessage}) {
        #{throw Exception(String(errorMessage))};
      }
    }
  }

  public async mkdirs() => mkdir(true)

  public async mkdir(Bool recursive = false, Bool: failOnExistsAlready = false) => true {
    external {
      if (failOnExistsAlready || !#{exists}) {
        await #{FileGlobal.fs}.promises.mkdir(#{location.chars.data}, {recursive: #{recursive}});
      }
    }
  }

  public async copy(File destination) => true {
    external {
      await #{FileGlobal.fs}.promises.copyFile(#{location.chars.data}, #{destination.location.chars.data});
    }
  }

  public async chmod(String mode) => true {
    external {
      await #{FileGlobal.fs}.promises.chmod(#{location.chars.data}, #{mode.chars.data});
    }
  }

  public async symbolicLinkTo(File target) => true {
    external {
      await new Promise((resolve, reject) => {
        #{FileGlobal.fs}.symlink(#{target.location.chars.data}, #{location.chars.data}, 'junction', (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
  }

  public static async symbolicLink(File from, File to) => from.symbolicLinkTo(to)

  public static class FileGlobal {
    external type FsType
    private static var FsType _fs
    visible static FsType fs {
      get {
        external {
          if (!#{_fs}) {
            #{_fs} = require('fs');
          }
        }

        return _fs
      }
    }

    external type PathType
    private static var PathType _path
    visible static PathType path {
      get {
        external {
          if (!#{_path}) {
            #{_path} = require('path');
          }
        }

        return _path
      }
    }
  }
}
